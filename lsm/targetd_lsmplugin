#!/usr/bin/env python

# Copyright (C) 2011 Red Hat, Inc.
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
#
# Author: Andy Grover <agrover at redhat com>

from lsm.iplugin import IStorageAreaNetwork
from lsm.common import LsmError, ErrorNumber, JobStatus, md5
from lsm.pluginrunner import PluginRunner
import sys
from lsm.data import Pool, Initiator, Volume, BlockRange, System
import urllib2
import json
import urlparse

default_user = "admin"
default_port = 18700
path = "/targetrpc"

class TargetdStorage(IStorageAreaNetwork):

    def startup(self, uri, password, timeout):
        self.uri = urlparse.urlsplit(uri)
        self.password = password
        self.tmo = timeout
        self.rpc_id = 1

    def set_time_out(self, ms):
        self.tmo = ms

    def get_time_out(self):
        return self.tmo

    def shutdown(self):
        pass

    def systems(self):
        return (System("targetd", "targetd storage appliance"),)

    def job_status(self, job_id):
        raise NotImplementedError

    def job_free(self, job_id):
        raise NotImplementedError

    def volumes(self):
        volumes = []
        for pool in (pool['name'] for pool in self._jsonrequest("pool_list")):
            for vol in self._jsonrequest("vol_list", dict(pool=pool)):
                volumes.append(Volume(vol['uuid'], vol['name'], vol['uuid'],
                                      512, vol['size']/512, Volume.STATUS_OK,
                                      None))
        return volumes

    def pools(self):
        pools = []
        for pool in self._jsonrequest("pool_list"):
            pools.append(Pool(pool['name'], pool['name'], pool['size'],
                              pool['free_size'], None))
        return pools

    def initiators(self):
        raise NotImplementedError

    def volume_create(self, pool, volume_name, size_bytes, provisioning):
        self._jsonrequest("vol_create", dict(pool=pool.name,
                                             name=volume_name, size=size_bytes))

    def volume_delete(self, volume):
        self._jsonrequest("vol_destroy", dict(pool=volume.pool.name, vol=volume.name))

    def volume_replicate(self, pool, rep_type, volume_src, name):
        if rep_type != Volume.REPLICATE_COPY:
            raise NotImplementedError

        self._jsonrequest("vol_copy",
                          dict(pool=pool.name, vol_orig=volume_src.name, vol_new=name))

    def volume_replicate_range_block_size(self):
        raise NotImplementedError

    def volume_replicate_range(self, rep_type, volume_src, volume_dest,
                               ranges):
        raise NotImplementedError

    def volume_online(self, volume):
        vol_list = self._jsonrequest("vol_list", dict(pool=volume.pool.name))

        return volume.name in [vol['name'] for vol in vol_list]

    def volume_offline(self, volume):
        return not volume_online(volume)

    def volume_resize(self, volume, new_size_bytes):
        raise NotImplementedError

    def access_group_grant(self, group, volume, access):
        raise NotImplementedError

    def access_group_revoke(self, group, volume):
        raise NotImplementedError

    def access_group_list(self):
        raise NotImplementedError

    def access_group_create(self, name, initiator_id, id_type, system_id):
        raise NotImplementedError

    def access_group_del(self, group):
        raise NotImplementedError

    def access_group_add_initiator(self, group, initiator_id, id_type):
        raise NotImplementedError

    def access_group_del_initiator(self, group, initiator):
        raise NotImplementedError

    def volumes_accessible_by_access_group(self, group):
        raise NotImplementedError

    def access_groups_granted_to_volume(self, volume):
        raise NotImplementedError

    def volume_child_dependency(self, volume):
        raise NotImplementedError

    def volume_child_dependency_rm(self, volume):
        raise NotImplementedError

    def _jsonrequest(self, method, params=None):
        data = json.dumps(dict(id=self.rpc_id, method=method,
                               params=params, jsonrpc="2.0"))
        self.rpc_id += 1

        user = self.uri.username or default_user
        port = self.uri.port or default_port
        if self.uri.password:
            print "password in URL not recommended, use -P option"
            self.password = self.uri.password
        host_with_port = "%s:%s" % (self.uri.hostname, port)
        url = urlparse.urlunsplit((self.uri.scheme, host_with_port, path, None, None))
        auth = ('%s:%s' % (user, self.password)).encode('base64')[:-1]
        headers = {'Content-Type': 'application/json',
                   'Authorization': 'Basic %s' % (auth,)}
        request = urllib2.Request(url, data, headers)
        response_obj = urllib2.urlopen(request)
        response_data = response_obj.read()
        response = json.loads(response_data)
        if response.get('error', None) is None:
            return response.get('result')
        else:
            if response['error']['code'] <= 0:
                raise Exception(response['error'].get('message', ''))
            else: # +code is async execution id
                print "Async completion, polling for results"
                async_code = response['error']['code']
                while True:
                    time.sleep(1)
                    results = jsonrequest('async_list')
                    status = results.get(str(async_code), None)
                    if status:
                        if status[0]:
                            print "%d has error %d" % (async_code, status[0])
                            break
                        else:
                            print "%d still going, %d%% complete" % \
                                (async_code, status[1])
                    else:
                        print "%s done" % async_code
                        break


if __name__ == '__main__':
    PluginRunner(TargetdStorage, sys.argv).run()
