#!/usr/bin/env python

# Copyright (C) 2011-2012 Red Hat, Inc.
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
#
# Author: tasleson

import sys
import urlparse
import pywbem
from pywbem.cim_operations import CIMError
from lsm.iplugin import IStorageAreaNetwork
from lsm.common import uri_parameters, LsmError, ErrorNumber, JobStatus
from lsm.pluginrunner import PluginRunner
from lsm.data import Pool, Initiator, Volume

def handle_cim_errors(method):
    def cim_wrapper(*args, **kwargs):
        try:
            return method(*args, **kwargs)
        except CIMError as ce:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, str(ce))
    return cim_wrapper


class Smis(IStorageAreaNetwork):
    """
    SMI-S plug-ing which exposes a small subset of the overall provided
    functionality of SMI-S
    """

    #SMI-S job 'JobState' enumerations
    (JS_NEW, JS_STARTING, JS_RUNNING, JS_SUSPENDED, JS_SHUTTING_DOWN, JS_COMPLETED,
     JS_TERMINATED, JS_KILLED, JS_EXCEPTION) = (2,3,4,5,6,7,8,9,10)

    #SMI-S job 'OperationalStatus' enumerations
    (JOB_OK, JOB_ERROR, JOB_STOPPED, JOB_COMPLETE) = (2,6,10,17)

    #SMI-S invoke return values we are interested in
    (INVOKE_OK, INVOKE_ASYNC) = (0, 4096)

    #SMI-S replication enumerations
    (SYNC_TYPE_MIRROR, SYNC_TYPE_SNAPSHOT, SYNC_TYPE_CLONE) = (6,7,8)

    #SMI-S volume 'OperationalStatus' enumerations
    (VOL_OP_STATUS_OK, VOL_OP_STATUS_DEGRADED, VOL_OP_STATUS_ERR, VOL_OP_STATUS_STARTING,
     VOL_OP_STATUS_DORMANT) = (2,3,6,8,15)

    #SMI-S ExposePaths device access enumerations
    (EXPOSE_PATHS_DA_READ_WRITE,EXPOSE_PATHS_DA_READ_ONLY) = (2,3)

    def __init__(self):
        self._c = None
        self._jobs = {}
        self._job_id = 1


    def _get_class_instance(self, class_name, prop_name=None, prop_value=None):
        """
        Gets an instance of a class that optionally matches a specific
        property name and value
        """
        instances = self._c.EnumerateInstances(class_name)

        if prop_name is None:
            if len(instances) != 1:
                class_names = " ".join([ x.classname for x in instances])
                raise LsmError(ErrorNumber.INTERNAL_ERROR, "Expecting one instance " \
                                                            "of " + class_name + " and got: " +
                                                            class_names)

            return instances[0]
        else:
            for i in instances:
                if i[prop_name] == prop_value:
                    return i

        raise LsmError(ErrorNumber.INVALID_ARGUMENT,
                        "Unable to find class instance " + class_name +
                        " with property " + prop_name +
                        " with value " + prop_value)

    def _get_pool(self, id):
        """
        Get a specific instance of a pool by pool id.
        """
        return self._get_class_instance("CIM_StoragePool", "PoolID", id)

    def _get_volume(self, id):
        """
        Get a specific instance of a volume by volume id.
        """
        return self._get_class_instance("CIM_StorageVolume", "DeviceID", id)

    def _get_spc(self, initiator_id, volume_id):
        """
        Retrieve the SCSIProtocolController for a given initiator and volume.
        This will return a non-none value when there is a mapping between the
        initiator and the volume.
        """
        init = self._get_class_instance('CIM_StorageHardwareID', 'StorageID', initiator_id)

        auths = self._c.Associators(init.path)

        for a in auths:
            spc = self._c.Associators(a.path)

            if len(spc) > 0:
                logical_device = self._c.Associators(spc[0].path)

                if len(logical_device) > 0:
                    vol = self._c.GetInstance(logical_device[0].path)

                    if 'DeviceID' in vol and vol['DeviceID'] == volume_id:
                        return spc[0]

        return None

    def _pi(self, msg, retrieve_vol, rc, out):
        """
        Handle the the process of invoking an operation.
        """

        #Check to see if operation is done
        if rc == Smis.INVOKE_OK:
            if retrieve_vol:
                return None, self._new_vol_from_name(out)
            else:
                return None, None

        elif rc == Smis.INVOKE_ASYNC:
            #We have an async operation
            self._job_id += 1
            self._jobs[self._job_id] = { 'job':out['Job'], 'retrieve_vol':retrieve_vol}
            return self._job_id, None
        else:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, 'Error: ' + msg + " rc= " + str(rc))

    def startup(self, uri, password, timeout):
        """
        Called when the plug-in runner gets the start request from the client.
        """
        protocol = 'http'
        u = urlparse.urlparse(uri)

        if u.scheme.lower() == 'smispy+ssl':
            protocol = 'https'

        url = protocol + '://' + u.hostname + ":" + str(u.port)

        params = uri_parameters(u)

        self.tmo = timeout
        self._c = pywbem.WBEMConnection(url, (u.username, password),
                                            params["namespace"] )

    def set_time_out(self, ms):
        self.tmo = ms

    def get_time_out(self):
        return self.tmo

    def shutdown(self):
        self._c = None
        self._jobs = None

    def _job_completed_ok(self, status):
        """
        Given a concrete job instance, check the operational status.  This is a
        little convoluted as different SMI-S proxies return the values in different
        positions in list :-)
        """
        rc = False
        op = status['OperationalStatus']

        if len(op) > 1 and \
            ((op[0] == Smis.JOB_OK and op[1] == Smis.JOB_COMPLETE) or
             (op[0] == Smis.JOB_COMPLETE and op[1] == Smis.JOB_OK)):
            rc = True

        return rc

    def _job_progress(self, job_record):
        """
        Given a concrete job instance name, check the status
        """
        volume = None
        percent_complete = 0

        job = job_record['job']
        get_vol = job_record['retrieve_vol']

        concrete_job =self._c.GetInstance(job)

        job_state = concrete_job['JobState']

        if job_state in(Smis.JS_NEW, Smis.JS_STARTING, Smis.JS_RUNNING):
            status = JobStatus.INPROGRESS

            pc = concrete_job['PercentComplete']
            if pc > 100:
                percent_complete = 100
            else:
                percent_complete = pc

        elif job_state == Smis.JS_COMPLETED:
            status = JobStatus.COMPLETE
            percent_complete = 100

            if self._job_completed_ok(concrete_job):
                if get_vol:
                    volume = self._new_vol_from_job(concrete_job)
            else:
                status = JobStatus.Error

            #See if we should delete the job
            if not concrete_job['DeleteOnCompletion']:
                try:
                    self._c.DeleteInstance(concrete_job.path)
                except CIMError:
                    pass
        else:
            status = JobStatus.ERROR

        return status, percent_complete, volume

    @handle_cim_errors
    def job_status(self, job_number):
        """
        Given a job number (integer) returns the current status as a tuple
        (status (enum), percent_complete(integer), volume (None or Volume))
        """
        if job_number in self._jobs:
            return self._job_progress(self._jobs[job_number])
        else:
            raise LsmError(ErrorNumber.INVALID_JOB_NUM, 'Non-existent job')

    def _new_vol(self, cv):
        """
        Takes a CIMInstance that represents a volume and returns a lsm Volume
        """
        status = Volume.STATUS_UNKNOWN

        if 'OperationalStatus' in cv:
            for s in cv["OperationalStatus"]:
                if s == Smis.VOL_OP_STATUS_OK:
                    status |= Volume.STATUS_OK
                elif s == Smis.VOL_OP_STATUS_DEGRADED:
                    status |= Volume.STATUS_DEGRADED
                elif s == Smis.VOL_OP_STATUS_ERR:
                    status |= Volume.STATUS_ERR
                elif s == Smis.VOL_OP_STATUS_STARTING:
                    status |= Volume.STATUS_STARTING
                elif s == Smis.VOL_OP_STATUS_DORMANT:
                    status |= Volume.STATUS_DORMANT

        return Volume(  cv["DeviceID"], cv["ElementName"],
                        cv["OtherIdentifyingInfo"][0], cv["BlockSize"],
                        cv["NumberOfBlocks"], status)

    def _new_vol_from_name(self, out):
        """
        Given a volume by CIMInstanceName, return a lsm Volume object
        """
        return self._new_vol(self._get_volume(out['TheElement']['DeviceID']))

    def _new_vol_from_job(self, job):
        """
        Given a concrete job instance, return referenced volume as lsm volume
        """
        associations = self._c.Associators(job.path)

        for a in associations:
            return self._new_vol(self._c.GetInstance(a.path))
        return None

    @handle_cim_errors
    def volumes(self):
        """
        Return all volumes.
        """
        volumes = self._c.EnumerateInstances('CIM_StorageVolume')
        return [ self._new_vol(v) for v in volumes ]

    @handle_cim_errors
    def pools(self):
        """
        Return all pools
        """
        pools = self._c.EnumerateInstances('CIM_StoragePool')
        return [ Pool(p["PoolID"], p["ElementName"],
                p["TotalManagedSpace"],
                p["RemainingManagedSpace"]) for p in pools if not p["Primordial"]]

    @staticmethod
    def _to_init(i):
        return Initiator(i["StorageID"], i["IDType"], i["ElementName"])

    @handle_cim_errors
    def initiators(self):
        """
        Return all initiators.
        """
        initiators = self._c.EnumerateInstances('CIM_StorageHardwareID')
        return [ Smis._to_init(i) for i in initiators ]

    @handle_cim_errors
    def volume_create(self, pool, volume_name, size_bytes, provisioning):
        """
        Create a volume.
        """
        if provisioning != Volume.PROVISION_DEFAULT:
            raise LsmError(ErrorNumber.UNSUPPORTED_PROVISIONING,
                            "Unsupported provisioning")

        scs = self._get_class_instance('CIM_StorageConfigurationService')
        sp = self._get_pool(pool.id)

        in_params = {   'ElementName' : volume_name,
                        'ElementType' : pywbem.Uint16(2),
                        'InPool':sp.path,
                        'Size': pywbem.Uint64(size_bytes) }

        return self._pi("volume_create", True,
            *(self._c.InvokeMethod('CreateOrModifyElementFromStoragePool',
            scs.path, **in_params)))

    @handle_cim_errors
    def volume_delete(self, volume):
        """
        Delete a volume
        """
        scs = self._get_class_instance('CIM_StorageConfigurationService')
        lun = self._get_volume(volume.id)

        in_params = { 'TheElement' : lun.path }

        #Delete returns None or Job number
        return self._pi("volume_delete", False,
                        *(self._c.InvokeMethod('ReturnToStoragePool', scs.path, **in_params)))[0]

    @handle_cim_errors
    def volume_resize(self, volume, new_size_bytes):
        """
        Re-size a volume
        """
        scs = self._get_class_instance('CIM_StorageConfigurationService')
        lun = self._get_volume(volume.id)

        in_params = { 'TheElement': lun.path, 'Size': pywbem.Uint64(new_size_bytes)}

        return self._pi("volume_resize", True,
                            *(self._c.InvokeMethod('CreateOrModifyElementFromStoragePool',
                            scs.path, **in_params)))

    @handle_cim_errors
    def volume_replicate(self, pool, rep_type, volume_src, name):
        """
        Replicate a volume
        """
        rs = self._get_class_instance("CIM_ReplicationService")
        pool = self._get_pool(pool.id)
        lun = self._get_volume(volume_src.id)

        if rep_type == Volume.REPLICATE_CLONE:
            sync = Smis.SYNC_TYPE_CLONE
        elif rep_type == Volume.REPLICATE_MIRROR:
            sync = Smis.SYNC_TYPE_MIRROR
        else:
            sync = Smis.SYNC_TYPE_SNAPSHOT

        in_params = {   'ElementName': name,
                        'SyncType' : pywbem.Uint16(sync),
                        'Mode': pywbem.Uint16(3),
                        'SourceElement': lun.path,
                        'TargetPool': pool.path}

        return self._pi("volume_replicate", True,
                                        *(self._c.InvokeMethod('CreateElementReplica',
                                        rs.path, **in_params)))

    @handle_cim_errors
    def volume_online(self, volume):
        return None

    @handle_cim_errors
    def volume_offline(self, volume):
        return None

    @handle_cim_errors
    def initiator_create(self, name, id, id_type):
        """
        Create initiator object
        """
        hardware = self._get_class_instance('CIM_StorageHardwareIDManagementService')

        in_params = {'ElementName':name,
                     'StorageID': id,
                     'IDType': pywbem.Uint16(id_type)}

        (rc, out) = self._c.InvokeMethod('CreateStorageHardwareID',
                                            hardware.path, **in_params)
        if not rc:
            init = self._get_class_instance('CIM_StorageHardwareID', 'StorageID', id)
            return Smis._to_init(init)

        raise LsmError(ErrorNumber.PLUGIN_ERROR, 'Error: ' + str(rc) +
                                                 ' on initiator_create!')

    @handle_cim_errors
    def initiator_delete(self, initiator):

        #Find the instance of the initiator to delete.
        init = self._get_class_instance('CIM_StorageHardwareID', 'StorageID',
                initiator.id)

        if init:
            hardware = self._get_class_instance('CIM_StorageHardwareIDManagementService')

            in_params = {'HardwareID': init.path}

            (rc, out) = self._c.InvokeMethod('DeleteStorageHardwareID',
                        hardware.path, **in_params)

            if not rc:
                return None
            else:
                raise LsmError(ErrorNumber.PLUGIN_ERROR, 'Error: ' + str(rc) +
                                                         ' on initiator_delete!')
        else:
            raise LsmError(ErrorNumber.PLUGIN_ERROR,
                'Error: initiator %s does not exist!' % initiator.id)

    @handle_cim_errors
    def access_grant(self, initiator, volume, access):
        """
        Grant access to a volume to an initiator
        """
        ccs = self._get_class_instance('CIM_ControllerConfigurationService')
        lun = self._get_volume(volume.id)

        if access == Volume.ACCESS_READ_ONLY:
            da = Smis.EXPOSE_PATHS_DA_READ_ONLY
        else:
            da = Smis.EXPOSE_PATHS_DA_READ_WRITE

        in_params = { 'LUNames': [lun['Name']],
                      'InitiatorPortIDs': [initiator.id],
                      'DeviceAccesses': [pywbem.Uint16(da)]}

        #Returns None or job id
        return self._pi("access_grant", False,
                *(self._c.InvokeMethod('ExposePaths', ccs.path, **in_params)))[0]

    @handle_cim_errors
    def access_revoke(self, initiator, volume):
        """
        Revoke access to a volume from an initiator
        """
        spc = self._get_spc(initiator.id, volume.id)

        if spc:
            ccs = self._get_class_instance('CIM_ControllerConfigurationService')

            in_params = {'ProtocolController': spc.path,
                         'DeleteChildrenProtocolControllers': True,
                         'DeleteUnits': True}

            #Returns None or job id
            return self._pi("access_revoke", False,
                *(self._c.InvokeMethod('DeleteProtocolController', ccs.path,
                    **in_params)))[0]

        raise LsmError(ErrorNumber.NO_MAPPING, "")

    @handle_cim_errors
    def job_free(self, job_number):
        """
        Frees the resources given a job number.
        """
        if job_number in self._jobs:
            del self._jobs[job_number]
            #It might be better to delete the actual job from the smi-s proxy
            #here!
        else:
            raise LsmError(ErrorNumber.INVALID_JOB_NUM, 'Non-existent job')

if __name__ == '__main__':
    PluginRunner(Smis, sys.argv).run()
