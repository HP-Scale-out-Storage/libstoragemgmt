#!/usr/bin/env python

# Copyright (C) 2011-2012 Red Hat, Inc.
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
#
# Author: tasleson

import sys
import urlparse
import pywbem
from pywbem.cim_operations import CIMError
from lsm.iplugin import IPlugin
from lsm.common import uri_parameters, LsmError, ErrorNumber, JobStatus
from lsm.pluginrunner import PluginRunner
from lsm.data import Pool, Initiator, Volume


(JS_NEW, JS_STARTING, JS_RUNNING, JS_SUSPENDED, JS_SHUTTING_DOWN, JS_COMPLETED,
 JS_TERMINATED, JS_KILLED, JS_EXCEPTION) = (2,3,4,5,6,7,8,9,10)

(OP_OK, OP_ERROR, OP_STOPPED, OP_COMPLETE) = (2,6,10,17)

(INVOKE_OK, INVOKE_ASYNC) = (0, 4096)

(SYNC_TYPE_MIRROR, SYNC_TYPE_SNAPSHOT, SYNC_TYPE_CLONE) = (6,7,8)

class Smis(IPlugin):

    def __init__(self):
        self.__c = None
        self.__jobs = {}
        self.__job_id = 1

    def __get_class_instance(self, class_name, prop_name=None, prop_value=None):
        """
        Gets an instance of a class that optionally matches a specific
        property name and value
        """
        instances = self.__c.EnumerateInstances(class_name)

        if prop_name is None:
            if len(instances) != 1:
                class_names = " ".join([ x.classname for x in instances])
                raise LsmError(ErrorNumber.INTERNAL_ERROR, "Expecting one instance " \
                                                            "of " + class_name + " and got: " +
                                                            class_names)

            return instances[0]
        else:
            for i in instances:
                if i[prop_name] == prop_value:
                    return i

        raise LsmError(ErrorNumber.INVALID_ARGUMENT,
                        "Unable to find class instance " + class_name +
                        " with property " + prop_name +
                        " with value " + prop_value)

    def __get_pool(self, id):
        return self.__get_class_instance("CIM_StoragePool", "PoolID", id)

    def __get_volume(self, id):
        return self.__get_class_instance("CIM_StorageVolume", "DeviceID", id)

    def __get_spc(self, initiator_id, volume_id):

        init = self.__get_class_instance('CIM_StorageHardwareID', 'StorageID', initiator_id)

        params = {}

        auths = self.__c.Associators(init.path, **params)

        for a in auths:
            spc = self.__c.Associators(a.path, **params)

            if len(spc) > 0:
                logical_device = self.__c.Associators(spc[0].path, **params)

                if len(logical_device) > 0:
                    vol = self.__c.GetInstance(logical_device[0].path, **params)

                    if 'DeviceID' in vol and vol['DeviceID'] == volume_id:
                        return True, spc[0]

        return False, None

    def __process_invoke(self, msg, retrieve_vol, rc, out):

        #Check to see if operation is done
        if rc == INVOKE_OK:
            if retrieve_vol:
                return None, self.__new_vol_from_name(out)
            else:
                return None, None

        elif rc == INVOKE_ASYNC:
            #We have an async operation
            self.__job_id += 1
            self.__jobs[self.__job_id] = { 'job':out['Job'], 'retrieve_vol':retrieve_vol}
            return self.__job_id, None
        else:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, 'Error: ' + msg + " rc= " + str(rc))

    def startup(self, uri, password, timeout):
        protocol = 'http'
        u = urlparse.urlparse(uri)

        s = u.scheme.lower()

        if s == 'smispy+ssl':
            protocol = 'https'

        url = protocol + '://' + u.hostname + ":" + str(u.port)

        params = uri_parameters(u)

        self.tmo = timeout
        self.__c = pywbem.WBEMConnection(url, (u.username, password),
                                            params["namespace"] )

    def set_time_out(self, ms):
        self.tmp = ms

    def get_time_out(self):
        return self.tmo

    def shutdown(self):
        self.__c = None

    def __job_completed_ok(self, status):
        rc = False
        op = status['OperationalStatus']

        if len(op) > 1 and \
            ((op[0] == OP_OK and op[1] == OP_COMPLETE) or
             (op[0] == OP_COMPLETE and op[1] == OP_OK)):
            rc = True

        return rc

    def __job_progress(self, job_record):
        volume = None
        percent_complete = 0

        job = job_record['job']
        get_vol = job_record['retrieve_vol']

        in_params = {}
        concrete_job =self.__c.GetInstance(job, **in_params)

        job_state = concrete_job['JobState']

        if job_state == JS_NEW or job_state == JS_STARTING or job_state == JS_RUNNING:
            status = JobStatus.INPROGRESS

            pc = concrete_job['PercentComplete']
            if pc > 100:
                percent_complete = 100
            else:
                percent_complete = pc

        elif job_state == JS_COMPLETED:
            status = JobStatus.COMPLETE
            percent_complete = 100

            if self.__job_completed_ok(concrete_job):
                if get_vol:
                    volume = self.__new_vol_from_job(concrete_job)
            else:
                status = JobStatus.Error

            #See if we should delete the job
            if not concrete_job['DeleteOnCompletion']:
                try:
                    self.__c.DeleteInstance(concrete_job.path)
                except CIMError:
                    pass
        else:
            status = JobStatus.ERROR

        return status, percent_complete, volume

    def job_status(self, job_number):
        if job_number in self.__jobs:
            return self.__job_progress(self.__jobs[job_number])
        else:
            raise LsmError(ErrorNumber.INVALID_JOB_NUM, 'Non-existent job')

    def __new_vol(self, cv):
        status = Volume.STATUS_UNKNOWN

        if 'OperationalStatus' in cv:
            for s in cv["OperationalStatus"]:
                if s == 2:
                    status |= Volume.STATUS_OK
                elif s == 3:
                    status |= Volume.STATUS_DEGRADED
                elif s == 6:
                    status |= Volume.STATUS_ERR
                elif s == 8:
                    status |= Volume.STATUS_STARTING
                elif s == 15:
                    status |= Volume.STATUS_DORMANT

        return Volume(  cv["DeviceID"], cv["ElementName"],
                        cv["OtherIdentifyingInfo"][0], cv["BlockSize"],
                        cv["NumberOfBlocks"], status)

    def __new_vol_from_name(self, out):
        return self.__new_vol(self.__get_volume(out['TheElement']['DeviceID']))

    def __new_vol_from_job(self, job):
        params = {}
        associations = self.__c.Associators(job.path, **params)

        for a in associations:
            return self.__new_vol(self.__c.GetInstance(a.path, **params))
        return None

    def volumes(self):
        try:
            volumes = self.__c.EnumerateInstances('CIM_StorageVolume')
            return [ self.__new_vol(v) for v in volumes ]
        except CIMError as ce:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, str(ce))

    def pools(self):
        try:
            pools = self.__c.EnumerateInstances('CIM_StoragePool')
            return [ Pool(p["PoolID"], p["ElementName"],
                    p["TotalManagedSpace"],
                    p["RemainingManagedSpace"]) for p in pools if not p["Primordial"]]
        except CIMError as ce:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, str(ce))

    def initiators(self):
        initiators = self.__c.EnumerateInstances('CIM_StorageHardwareID')
        return [ Initiator(i["StorageID"], i["IDType"]) for i in initiators ]

    def volume_create(self, pool, volume_name, size_bytes, provisioning):
        if provisioning != Volume.PROVISION_DEFAULT:
            raise LsmError(ErrorNumber.UNSUPPORTED_PROVISIONING,
                            "Unsupported provisioning")

        try:
            scs = self.__get_class_instance('CIM_StorageConfigurationService')
            sp = self.__get_pool(pool.id)

            in_params = {   'ElementName' : volume_name,
                            'ElementType' : pywbem.Uint16(2),
                            'InPool':sp.path,
                            'Size': pywbem.Uint64(size_bytes) }

            return self.__process_invoke("volume_create", True,
                *(self.__c.InvokeMethod('CreateOrModifyElementFromStoragePool',
                scs.path, **in_params)))

        except CIMError as ce:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, str(ce))

    def volume_delete(self, volume):
        try:
            scs = self.__get_class_instance('CIM_StorageConfigurationService')
            lun = self.__get_volume(volume.id)

            in_params = { 'TheElement' : lun.path }

            #Delete returns None or Job number
            return self.__process_invoke("volume_delete", False,
                            *(self.__c.InvokeMethod('ReturnToStoragePool', scs.path, **in_params)))[0]

        except CIMError as ce:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, str(ce))

    def volume_resize(self, volume, new_size_bytes):
        try:
            scs = self.__get_class_instance('CIM_StorageConfigurationService')
            lun = self.__get_volume(volume.id)

            in_params = { 'TheElement': lun.path, 'Size': pywbem.Uint64(new_size_bytes)}

            return self.__process_invoke("volume_resize", True,
                                *(self.__c.InvokeMethod('CreateOrModifyElementFromStoragePool',
                                scs.path, **in_params)))
        except CIMError as ce:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, str(ce))

    def volume_replicate(self, pool, rep_type, volume_src, name):
        try:
            rs = self.__get_class_instance("CIM_ReplicationService")
            pool = self.__get_pool(pool.id)
            lun = self.__get_volume(volume_src.id)

            if rep_type == Volume.REPLICATE_CLONE:
                sync = SYNC_TYPE_CLONE
            elif rep_type == Volume.REPLICATE_MIRROR:
                sync = SYNC_TYPE_MIRROR
            else:
                sync = SYNC_TYPE_SNAPSHOT

            in_params = {   'ElementName': name,
                            'SyncType' : pywbem.Uint16(sync),
                            'Mode': pywbem.Uint16(3),
                            'SourceElement': lun.path,
                            'TargetPool': pool.path}

            return self.__process_invoke("volume_replicate", True,
                                            *(self.__c.InvokeMethod('CreateElementReplica',
                                            rs.path, **in_params)))
        except CIMError as ce:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, str(ce))

    def volume_online(self, volume):
        return None

    def volume_offline(self, volume):
        return None

    def initiator_create(self, name, id, id_type):
        try:
            hardware = self.__get_class_instance('CIM_StorageHardwareIDManagementService')

            in_params = {'ElementName':name,
                         'StorageID': id,
                         'IDType': pywbem.Uint16(id_type)}

            (rc, out) = self.__c.InvokeMethod('CreateStorageHardwareID',
                                                hardware.path, **in_params)
            if not rc:
                return Initiator(id, id_type)

            raise LsmError(ErrorNumber.PLUGIN_ERROR, 'Error: ' + str(rc) +
                                                     ' on initiator_create!')
        except CIMError as ce:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, str(ce))

    def access_grant(self, initiator, volume, access):
        try:
            ccs = self.__get_class_instance('CIM_ControllerConfigurationService')
            lun = self.__get_volume(volume.id)

            if access == Volume.ACCESS_READ_ONLY:
                da = 3
            else:
                da = 2

            in_params = { 'LUNames': [lun['Name']],
                          'InitiatorPortIDs': [initiator.id],
                          'DeviceAccesses': [pywbem.Uint16(da)]}

            #Returns None or job id
            return self.__process_invoke("access_grant", False,
                    *(self.__c.InvokeMethod('ExposePaths', ccs.path, **in_params)))[0]
        except CIMError as ce:
            raise LsmError(ErrorNumber.PLUGIN_ERROR, str(ce))

    def access_revoke(self, initiator, volume):
        try:
            (found, spc) = self.__get_spc(initiator.id, volume.id)

            if found:
                ccs = self.__get_class_instance('CIM_ControllerConfigurationService')

                in_params = dict(ProtocolController=spc.path,
                    DeleteChildrenProtocolControllers=True, DeleteUnits=True)

                #Returns None or job id
                return self.__process_invoke("access_revoke", False,
                    *(self.__c.InvokeMethod('DeleteProtocolController', ccs.path,
                        **in_params)))[0]

            raise LsmError(ErrorNumber.NO_MAPPING, "")
        except CIMError as ce:
            raise LsmError(ErrorNumber.LSM_ERR_PLUGIN_ERROR, str(ce))

    def job_free(self, job_number):
        if job_number in self.__jobs:
            del self.__jobs[job_number]
            #It might be better to delete the actual job from the smi-s proxy
            #here!
        else:
            raise LsmError(ErrorNumber.INVALID_JOB_NUM, 'Non-existent job')

if __name__ == '__main__':
    PluginRunner(Smis, sys.argv).run()
